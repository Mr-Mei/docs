import{_ as n,o as a,c as s,e}from"./app-58db18e7.js";const t="/images/Vue/数据双向绑定.png",o="/images/Vue/MVVM工作原理.png",l="/images/Vue/基本使用步骤.png",p="/images/Vue/事件修饰符.png",i="/images/Vue/双向绑定指令.png",r="/images/Vue/选择配置项1.png",c="/images/Vue/选择配置项2.png",u="/images/Vue/安装配置完成.png",d="/images/Vue/项目说明.png",h="/images/Vue/组件的生命周期.png",k="/images/Vue/父传子.png",m="/images/Vue/子传父.png",v="/images/Vue/兄弟组件数据共享.png",g={},b=e('<h1 id="vue2-基础知识" tabindex="-1"><a class="header-anchor" href="#vue2-基础知识" aria-hidden="true">#</a> Vue2 基础知识</h1><h2 id="一-vue-简介" tabindex="-1"><a class="header-anchor" href="#一-vue-简介" aria-hidden="true">#</a> 一.vue 简介</h2><h3 id="_1-概念" tabindex="-1"><a class="header-anchor" href="#_1-概念" aria-hidden="true">#</a> 1. 概念</h3><p>用于构建用户界面的前端框架</p><h3 id="_2-特性" tabindex="-1"><a class="header-anchor" href="#_2-特性" aria-hidden="true">#</a> 2. 特性</h3><p>vue两大特性： <strong>数据驱动视图</strong>，<strong>双向数据绑定</strong></p><h4 id="_1-数据驱动视图" tabindex="-1"><a class="header-anchor" href="#_1-数据驱动视图" aria-hidden="true">#</a> (1) 数据驱动视图</h4><ul><li>数据变化会驱动视图自动更新，当数据发生变化时，vue会监听数据变化，从而自动重新渲染页面结构(无须手动操作DOM)</li><li>单向的数据绑定(数据变化导致页面变化)</li></ul><h4 id="_2-双向数据绑定" tabindex="-1"><a class="header-anchor" href="#_2-双向数据绑定" aria-hidden="true">#</a> (2) 双向数据绑定</h4><ul><li><p>在填写表单时，双向数据绑定可以辅助开发者在不操作DOM 的前提下，自动把用户填写的内容同步到数据源中</p></li><li><p>js数据发生变化，会自动渲染到页面上；页面表单数据发生变化时，被vue自动获取并更新到js中</p><p><img src="'+t+'" alt="e1db5b7088db4ee2ab4cec5c65291b14.png"></p></li></ul><h3 id="_3-mvvm" tabindex="-1"><a class="header-anchor" href="#_3-mvvm" aria-hidden="true">#</a> 3. MVVM</h3><ul><li><p>MVVM是vue实现数据驱动视图和双向数据绑定的核心原理(底层)</p></li><li><p>MVVM指<strong>Model</strong>(数据源)，<strong>View</strong>(DOM结构)和<strong>ViewModel</strong>(vue实例)</p></li><li><p>它把每个HTML页面都拆分成了这三个部分 (<strong>Model表示当前页面渲染时所依赖的数据源</strong>，<strong>View表示当前页面所渲染的DOM结构</strong>，<strong>ViewModel表示vue的实例</strong>，它是MVVM的核心)</p><p><img src="'+o+'" alt="e027dd474fcc4f5da6cf052234cb3562.png"></p></li><li><p>当数据源发生变化时，会被ViewModel监听到，并自动重新渲染页面结构</p></li><li><p>当表单元素的值发生变化时，也会被ViewModel监听到并把变化后最新的值自动同步到Model数据源中</p></li></ul><h3 id="_4-基本使用步骤" tabindex="-1"><a class="header-anchor" href="#_4-基本使用步骤" aria-hidden="true">#</a> 4. 基本使用步骤</h3><ul><li>导入 vue.js 的 script 脚本文件</li><li>在页面中声明一个将要被 vue 所控制的 DOM 区域（class选择器或id选择器）</li><li>创建 vm 实例对象（vue 实例对象）</li><li><img src="'+l+'" alt="aa192eecb97845d39ba752d41b289e48.png"></li></ul><h3 id="_5-调试工具" tabindex="-1"><a class="header-anchor" href="#_5-调试工具" aria-hidden="true">#</a> 5. 调试工具</h3><ul><li>浏览器更多工具 ==&gt; 扩展程序(将下载的文件拖入即可) ==&gt; Vue.js devtools详细信息(勾选在所有网络上, 允许访问文件网址即可)</li><li>Chrome浏览器在线安装 vue-devtools： https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd</li><li>FireFox浏览器在线安装： https://addons.mozilla.org/zh-CN/firefox/addon/vue-js-devtools/</li></ul><h3 id="_6" tabindex="-1"><a class="header-anchor" href="#_6" aria-hidden="true">#</a> 6. <code>{{ }}</code></h3><ul><li>插值表达式Mustache，只是内容占位符，不覆盖原有内容</li><li>只能用在元素内容节点，不能用在属性节点 <code>&lt;p&gt;性别: {{ sex }}&lt;/p&gt;</code></li><li>不能识别标签</li></ul><h2 id="二-vue-基础" tabindex="-1"><a class="header-anchor" href="#二-vue-基础" aria-hidden="true">#</a> 二. vue 基础</h2><h3 id="_1-指令" tabindex="-1"><a class="header-anchor" href="#_1-指令" aria-hidden="true">#</a> 1. 指令</h3><p>指令(Directives)是vue为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构，vue 中的指令按照不同的用途可以分为6大类</p><h4 id="_1-内容渲染指令" tabindex="-1"><a class="header-anchor" href="#_1-内容渲染指令" aria-hidden="true">#</a> (1) 内容渲染指令</h4><p>用来辅助开发者渲染DOM元素的文本内容。常用的内容渲染指令有如下 2个</p><ul><li>v-text：会覆盖元素默认内容<code> &lt;p v-text=&quot;username&quot;&gt;&lt;/p&gt;</code></li><li>v-html： 渲染带标签的内容，并实现标签样式，会覆盖元素默认内容 <code>&lt;div v-html=&quot;属性&quot;&gt;&lt;/div&gt;</code></li></ul><h4 id="_2-属性绑定指令" tabindex="-1"><a class="header-anchor" href="#_2-属性绑定指令" aria-hidden="true">#</a> (2) 属性绑定指令</h4><ul><li>v-bind (简写 : )：为元素的属性动态绑定属性值, 单向绑定(数据源影响DOM变化)</li><li>支持绑定简单的数据值 <code>&lt;img src=&quot;&quot; :placeholder=&quot;tips&quot;&gt;</code></li><li>支持绑定js表达式的简单运算<code>&lt;div :title=&quot; &#39;box-&#39; + index&quot;&gt;div盒子&lt;/div&gt;</code></li></ul><h4 id="_3-事件绑定指令" tabindex="-1"><a class="header-anchor" href="#_3-事件绑定指令" aria-hidden="true">#</a> (3) 事件绑定指令</h4><ul><li>v-on(简写@)：为DOM元素绑定事件监听</li><li>处理函数写在实例对象的methods属性下 <code>&lt;button @click=&quot;add()&quot;&gt;点击&lt;/button&gt;</code> ()可传参，无需传参可写成：@click=&quot;add&quot;</li><li>原生DOM对象onclick，oninput，onkeyup等原生事件，替换为@click，@input，@keyup</li></ul><p><strong>$event</strong></p><p>vue 提供的特殊变量，表示原生的事件参数对象event， 可解决事件参数对象event被覆盖的问题(点击按钮变色问题)</p><p><strong>事件修饰符</strong></p><p>方便对事件的触发控制 <code>&lt;a href=&quot; &quot; @click.prevent=&quot; &quot;&gt;&lt;/a&gt;</code></p><p><img src="'+p+'" alt="dfa249a858f646768740af687f2fad25.png"></p><p><strong>按键修饰符</strong></p><p>监听键盘事件时，判断详细的按键，可为键盘相关的事件添加按键修饰符</p><p>e.g:<code>&lt;input @keyup.enter=&quot;submit&quot;&gt;</code>只有按键Enter时，调用submit()</p><h4 id="_4-双向绑定指令" tabindex="-1"><a class="header-anchor" href="#_4-双向绑定指令" aria-hidden="true">#</a> (4) 双向绑定指令</h4><p>v-model：双向数据绑定指令，不操作DOM的前提下，快速获取表单的数据</p><p><img src="'+i+'" alt="44bb3c8e1dfc41c09dc30f0b3bc9082e.png"></p><h4 id="_5-条件渲染指令" tabindex="-1"><a class="header-anchor" href="#_5-条件渲染指令" aria-hidden="true">#</a> (5) 条件渲染指令</h4><p>按需控制 DOM 的显示与隐藏</p><ul><li>v-if：动态创建或移出实现元素显示与隐藏，有更高的切换开销，在运行时条件很少改变，使用较好(e.g：刚进入页面时，某些元素默认不需要被展示，后期也不需展示)</li><li>v-show：动态为元素添加或移除style=&quot;display: none;&quot; 样式实现显示与隐藏，有更高的初始渲染开销， 需要非常频繁地切换，使用较好</li><li>v-else 必须配合v-if指令一起使用，否则不会被识别</li><li>v-else-if 必须配合v-if指令一起使用，否则不会被识别</li></ul><h4 id="_6-列表渲染指令" tabindex="-1"><a class="header-anchor" href="#_6-列表渲染指令" aria-hidden="true">#</a> (6) 列表渲染指令</h4><ul><li>v-for：基于一个数组来循环渲染一个列表结构</li><li>使用item in list形式特殊语法(list待循环数组，item被循环的每一项)</li><li>用索引时(item, index) in list , item项和index 索引都是形参，可重命名</li></ul><p><strong>使用key维护列表状态</strong></p><ul><li>官方建议，使用v-for必须绑定属性key，且值通常为id(唯一id)</li><li>当列表的数据变化时，默认情况下，vue会尽可能的复用已存在的DOM元素，从而提升渲染的性能，但这种默认的性能优化策略，会导致有状态的列表无法被正确更新</li><li>为给vue一个提示，以便它能跟踪每个节点的身份，从而在保证有状态的列表被正确更新的前提下，提升渲染的性能，需要为每项提供一个唯一的key属性</li><li>e.g：<code>&lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot; :title=&quot;index + item.uname&quot;&gt;</code></li></ul><p><strong>key的注意事项</strong></p><ul><li>key 的值只能是字符串或数字类型</li><li>key 的值必须具有唯一性（即：key的值不能重复）</li><li>建议把数据项 id 属性的值作为key的值（id 属性的值具有唯一性）</li><li>使用 index 的值当作key的值没有任何意义（index 的值不具有唯一性，与每一项无强制关系）</li><li>建议使用v-for指令时一定要指定key的值（既提升性能、又防止列表状态紊乱）</li></ul><h3 id="_2-过滤器" tabindex="-1"><a class="header-anchor" href="#_2-过滤器" aria-hidden="true">#</a> 2. 过滤器</h3><h4 id="_1-概念-1" tabindex="-1"><a class="header-anchor" href="#_1-概念-1" aria-hidden="true">#</a> (1) 概念</h4><ul><li>过滤器(Filters)常用于文本的格式化，过滤器可以用在插值表达式和v-bind属性绑定中</li><li>过滤器应该被添加在JS表达式的尾部，由管道符( | )进行调用，可连续多个调用，前边的处理结果传递给后边的过滤器</li><li>本质是js函数，可接受参数</li></ul><p><strong>兼容性</strong></p><p>仅在vue 2.x和1.x中支持,在 vue 3.x 的版本中剔除了过滤器相关的功能(官方建议使用计算属性或方法代替被剔除的过滤器功能 )</p><h4 id="_2-分类" tabindex="-1"><a class="header-anchor" href="#_2-分类" aria-hidden="true">#</a> (2) 分类</h4><p><strong>私有过滤器</strong></p><ul><li>在 filters 节点下定义的过滤器，只能在当前 vm 实例所控制的 el 区域内使用</li></ul><p><strong>全局过滤器</strong></p><ul><li>多个 vue 实例之间共享过滤器</li><li>Vue.filter(&#39;过滤器名&#39;, (参1, 参2,参3)=&gt;{ }) 必须定义在vue实例之前</li><li>参数1永远为管道符| 前边待处理的值，第二个参数开始，才是调用过滤器传递的参数</li></ul><h3 id="_3-侦听器" tabindex="-1"><a class="header-anchor" href="#_3-侦听器" aria-hidden="true">#</a> 3. 侦听器</h3><ul><li>watch侦听器监视数据的变化，从而针对数据的变化做特定的操作，写在watch节点下</li><li>侦听器本质是一个函数，监视哪个数据,就将他作为函数名，参数中新值在前，旧值在后</li><li>immediate选项：实现初次页面渲染好，侦听器立即被调用 immediate: true, 默认false</li><li>deep选项：深度侦听, 可监听对象中的属性的变化 deep: true</li><li>侦听对象中的单个属性：对象.属性:{ handler(参数){ } } handler为侦听器处理函数</li></ul><h3 id="_4-计算属性" tabindex="-1"><a class="header-anchor" href="#_4-计算属性" aria-hidden="true">#</a> 4. 计算属性</h3><ul><li>计算属性指的是通过一系列运算之后，最终得到一个属性值，写在computed节点下</li><li>定义为方法格式，使用时按属性使用，实现代码复用</li><li>会缓存计算的结果，只有依赖数据源变化，计算属性会重新求值</li></ul><h3 id="_5-vue-cli" tabindex="-1"><a class="header-anchor" href="#_5-vue-cli" aria-hidden="true">#</a> 5. vue-cli</h3><h4 id="_1-单页面应用程序" tabindex="-1"><a class="header-anchor" href="#_1-单页面应用程序" aria-hidden="true">#</a> (1) 单页面应用程序</h4><p>Single Page Application简称 SPA，指一个Web网站中只有唯一的一个HTML页面，所有的功能与交互都在这唯一的一个页面内完成</p><h4 id="_2-vue-cli" tabindex="-1"><a class="header-anchor" href="#_2-vue-cli" aria-hidden="true">#</a> (2) vue-cli</h4><ul><li>Vue.js开发的标准工具， 简化了程序员基于webpack创建工程化的Vue 项目的过程</li><li>https://cli.vuejs.org/zh/</li><li>安装: npm i -g @vue/cli</li></ul><h4 id="_3-使用" tabindex="-1"><a class="header-anchor" href="#_3-使用" aria-hidden="true">#</a> (3) 使用</h4><ul><li>基于vue-cli快速生成工程化的Vue项目：vue create 项目的名称 (不包含大写、汉字、空格等)</li><li>选择配置项<img src="'+r+'" alt="0c25bba633c14d1fa42c5c57becee5bf.png"><img src="'+c+'" alt="img"></li><li>自动创建项目，初始化git，以及安装所需依赖包</li><li>安装配置完成后，显示npm run serve 以开发的方式运行项目(serve相当于dev， 配置文件scripts节点中，发布build)<img src="'+u+'" alt="2b102d6fb6024c5b8da5faef3324cecb.png"></li><li>项目目录说明 <img src="'+d+'" alt="99a0e81425dc4ba493c4269110540cb7.png"></li></ul><h3 id="_6-组件" tabindex="-1"><a class="header-anchor" href="#_6-组件" aria-hidden="true">#</a> 6. 组件</h3><h4 id="_1-组件化开发" tabindex="-1"><a class="header-anchor" href="#_1-组件化开发" aria-hidden="true">#</a> (1) 组件化开发</h4><ul><li>根据封装的思想，把页面上可重用的 UI 结构封装为组件，从而方便项目的开发和维护</li><li>vue 是一个支持组件化开发的前端框架，vue中的组件后缀名是 .vue</li></ul><h4 id="_2-vue组件组成部分" tabindex="-1"><a class="header-anchor" href="#_2-vue组件组成部分" aria-hidden="true">#</a> (2) vue组件组成部分</h4><p><strong>template</strong></p><ul><li>组件的模板结构(必选)</li><li>只起到包裹性质的作用，不会被渲染为真正的DOM 元素</li><li>只能包含唯一根节点</li></ul><p><strong>script</strong></p><ul><li>组件的JavaScript行为(可选)</li><li>只要写script，其中必须包含export default{ 可包含data， methods... }默认导出</li><li>组件中的数据源data必须是个函数，return的对象中可定义数据; 不能直接指向一个数据对象(会导致多个组件实例共用同一份数据的问题) e.g：data(){ return { username: &#39;ff&#39; } }</li></ul><p><strong>style</strong></p><ul><li>组件的样式(可选)</li><li>启用sass预处理器 <code>&lt;style lang=&quot;scss&quot;&gt;</code></li></ul><h4 id="_3-组件的使用" tabindex="-1"><a class="header-anchor" href="#_3-组件的使用" aria-hidden="true">#</a> (3) 组件的使用</h4><p><strong>关系</strong></p><ul><li>组件在被封装好之后，彼此之间是相互独立的，不存在父子关系</li><li>在使用组件的时候，根据彼此的嵌套关系，形成了父子关系、兄弟关系</li></ul><p><strong>使用步骤</strong></p><ul><li>使用components节点注册组件，components:{ Left , // &#39;Left&#39;: Left 简写 }</li><li>使用import 语法导入需要的组件，import Left from &#39;@/components/left.vue&#39;</li><li>以标签形式使用刚才注册的组件，template中<code>&lt;Left&gt;&lt;/Left&gt;</code></li></ul><p><strong>私有子组件</strong></p><ul><li>通过components注册的是私有子组件</li><li>在组件A的components节点下，注册组件F，则组件F只能用在组件A中，不能被用在组件B中</li></ul><p><strong>全局组件</strong></p><ul><li>main.js 入口文件中，通过 Vue.component()方法，可以注册全局组件</li><li>import Custom from &#39;@/components/Custom.vue&#39;; Vue.component(&#39;MyCustom&#39;,Custom)</li></ul><h4 id="_4-props" tabindex="-1"><a class="header-anchor" href="#_4-props" aria-hidden="true">#</a> (4) props</h4><ul><li>自定义属性，封装通用组件使用，可提高组件的复用性</li><li>prop:[&#39;自定义A&#39;, &#39;自定义B&#39;...]，props:{ 属性A:{ //默认值... }}</li><li>自定义属性是只读的，不能直接修改props的值，否则会直接报错，需要修改 props 的值，可以把 props 的值转存到data中(data 中的数据都是可读可写)</li><li>default 声明自定义属性时，定义属性的默认值 (未传，则用默认值)</li><li>type 声明自定义属性时，定义属性的值类型(传过来的值类型不符则报错)</li><li>required 将属性设置为必填项，强制用户必须传递属性的值(校验有无该属性，与默认值无关)</li></ul><h4 id="_5-组件样式冲突" tabindex="-1"><a class="header-anchor" href="#_5-组件样式冲突" aria-hidden="true">#</a> (5) 组件样式冲突</h4><ul><li>默认情况下，写在 .vue 组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题</li></ul><p>根本原因是：</p><ul><li>单页面应用程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的</li><li>每个组件中的样式，都会影响整个index.html页面中的DOM</li></ul><p><strong>解决:</strong></p><ul><li>为每个组件分配唯一的自定义属性，通过属性选择器来控制样式的作用域</li><li>scoped属性<code>&lt;style scoped&gt;&lt;/style&gt; </code>可防止组件之间的样式冲突，但当前组件的样式对其子组件是不生效</li><li>/deep/ 、::v-deep等深度选择器，可进行样式穿透，让某些样式对子组件生效</li></ul><h3 id="_7-组件的生命周期" tabindex="-1"><a class="header-anchor" href="#_7-组件的生命周期" aria-hidden="true">#</a> 7. 组件的生命周期</h3><h4 id="_1-概念-2" tabindex="-1"><a class="header-anchor" href="#_1-概念-2" aria-hidden="true">#</a> (1) 概念</h4><ul><li>生命周期(Life Cycle)是指一个组件从<strong>创建</strong> ==&gt; <strong>运行</strong> ==&gt; <strong>销毁</strong>的整个阶段，强调的是一个时间段</li><li>生命周期函数：内置函数，会伴随着组件的生命周期，自动按次序执行，强调的是时间点</li></ul><h4 id="_2-分类-1" tabindex="-1"><a class="header-anchor" href="#_2-分类-1" aria-hidden="true">#</a> (2) 分类</h4><ul><li>组件创建阶段 new Vue() ==&gt; beforeCreate ==&gt; created ==&gt; beforeMount ==&gt; mounted</li><li>组件运行阶段 beforeUpdate ==&gt; updated</li><li>组件销毁阶段 beforeDestroy ==&gt; destroyed</li></ul><p><img src="'+h+'" alt="2512e3144d5b4e6d9239933bd4fe6f4a.png"></p><h3 id="_8-数据共享" tabindex="-1"><a class="header-anchor" href="#_8-数据共享" aria-hidden="true">#</a> 8. 数据共享</h3><h4 id="_1-父向子组件数据共享" tabindex="-1"><a class="header-anchor" href="#_1-父向子组件数据共享" aria-hidden="true">#</a> (1) 父向子组件数据共享</h4><p>使用自定义属性</p><p><img src="'+k+'" alt="01fbcc4232234b83a6a44ddac6e99bab.png"></p><h4 id="_2-子向父组件数据共享" tabindex="-1"><a class="header-anchor" href="#_2-子向父组件数据共享" aria-hidden="true">#</a> (2) 子向父组件数据共享</h4><p>使用自定义事件</p><p><img src="'+m+'" alt="40d333942c774392b2e065dba38c28ee.png"></p><h4 id="_3-兄弟组件数据共享" tabindex="-1"><a class="header-anchor" href="#_3-兄弟组件数据共享" aria-hidden="true">#</a> (3) 兄弟组件数据共享</h4><p>在 vue2.x 中，兄弟组件之间数据共享的方案是 EventBus (eventBus.js)</p><p><img src="'+v+`" alt="65bf2e2c2bc14e229b85ae6f6902751c.png"></p><h3 id="_9-ref引用" tabindex="-1"><a class="header-anchor" href="#_9-ref引用" aria-hidden="true">#</a> 9. ref引用</h3><ul><li>ref 用来辅助开发者在不依赖于 jQuery 的情况下，获取 DOM 元素或组件的引用</li><li>$refs 对象：每个vue的组件实例上都包含一个，里面存储着对应的DOM元素或组件的引用，默认$refs指向一个空对象</li><li>使用ref，为子组件创建实例，可直接操作子组件中的方法和属性 <code> &lt;Myref ref=&quot;comRef&quot;&gt;&lt;/Myref&gt;</code></li></ul><p><strong>this.$nextTick(callback) 方法</strong></p><ul><li>会把 callback 回调推迟到下一个DOM更新周期之后执行</li><li>等组件的DOM更新完成后，再执行callback回调函数，从而能保证callback回调函数操作的是最新DOM元素</li></ul><h3 id="_10-动态组件" tabindex="-1"><a class="header-anchor" href="#_10-动态组件" aria-hidden="true">#</a> 10. 动态组件</h3><h4 id="_1-概念-3" tabindex="-1"><a class="header-anchor" href="#_1-概念-3" aria-hidden="true">#</a> (1) 概念</h4><ul><li>动态组件指的是动态切换组件的显示与隐藏</li><li>通过内置组件<code>&lt;component&gt;</code>，专门实现动态组件的渲染<code> &lt;component is=&quot;Left&quot;&gt;&lt;/component&gt;</code></li><li>可绑定is属性，实现动态切换 <code>&lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;</code></li></ul><h4 id="_2-keep-alive" tabindex="-1"><a class="header-anchor" href="#_2-keep-alive" aria-hidden="true">#</a> (2) keep-alive</h4><ul><li><code>&lt;keep-alive&gt;</code> 组件保持状态，默认情况下，切换动态组件时无法保持组件的状态(会将组件销毁)</li></ul><p><strong>keep-alive 对应的生命周期函数</strong></p><ul><li>当组件被缓存时，会自动触发组件的 deactivated 生命周期函数</li><li>当组件被激活时，会自动触发组件的 activated 生命周期函数</li></ul><p><strong>属性</strong></p><ul><li>include: 指定可以缓存的组件，其余组件切换后就会被销毁</li><li>exclude: 指定不被缓存的组件</li><li>include和exclude，只能选择其一，不能同时使用</li></ul><h4 id="_3-name" tabindex="-1"><a class="header-anchor" href="#_3-name" aria-hidden="true">#</a> (3) name</h4><ul><li>name属性，用于组件声明时，指定该组件名称，结合keep-alive标签实现组件缓存功能，在调试工具中显示</li><li>注册组件时名称，用于以标签形式，把注册好的组件渲染显示到页面中 components:{ Header }</li></ul><h3 id="_11-插槽" tabindex="-1"><a class="header-anchor" href="#_11-插槽" aria-hidden="true">#</a> 11. 插槽</h3><h4 id="_1-概念-4" tabindex="-1"><a class="header-anchor" href="#_1-概念-4" aria-hidden="true">#</a> (1) 概念</h4><ul><li>插槽(Slot)是vue为组件的封装者提供的能力，允许开发者在封装组件时，把不确定的，希望由用户指定的部分定义为插槽 (为用户预留的内容的占位符)</li><li>未使用<code>&lt;template&gt;</code>包裹需要填充的内容，默认填充到default插槽中</li><li>若在封装组件时没有预留任何<code> &lt;slot&gt;</code> 插槽，则用户提供的任何自定义内容都会被丢弃</li><li>后备内容：插槽中写的内容，优先填充显示用户自定义内容，若没有填充到插槽中的内容，则显示后备内容</li></ul><h4 id="_2-具名插槽" tabindex="-1"><a class="header-anchor" href="#_2-具名插槽" aria-hidden="true">#</a> (2) 具名插槽</h4><ul><li><code>&lt;slot name=&quot;xxx&quot;&gt;&lt;/slot&gt; </code>带有具体名称的插槽叫做“具名插槽”</li><li>没有指定name 名称的插槽，默认插槽名为default</li></ul><p><strong>v-slot:(#)指令:</strong></p><ul><li>v-slot(#)指令，指定填充到哪个插槽</li><li>不能直接用在元素上，要用在<code>&lt;template&gt;</code>虚拟标签上</li></ul><h4 id="_3-作用域插槽" tabindex="-1"><a class="header-anchor" href="#_3-作用域插槽" aria-hidden="true">#</a> (3) 作用域插槽</h4><ul><li><code>&lt;slot&gt; </code>插槽绑定props数据(自定义属性及值或动态数据)</li><li>&#39;&lt;template #content=&quot;scope&quot;&gt; &#39; 可用scope形参来接收对象</li><li>接收过来的对象，可直接解构拿到其中属性 { msg, user }</li></ul><h3 id="_12-自定义指令" tabindex="-1"><a class="header-anchor" href="#_12-自定义指令" aria-hidden="true">#</a> 12. 自定义指令</h3><h4 id="_1-私有自定义指令" tabindex="-1"><a class="header-anchor" href="#_1-私有自定义指令" aria-hidden="true">#</a> (1) 私有自定义指令</h4><ul><li><p>directives 节点下声明</p></li><li><p>使用时，加v-前缀即可，template 结构中可以通过=为当前指令动态绑定参数值</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 私有自定义指令节点</span>
<span class="token literal-property property">directives</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token comment">/* color:{ // 定义名为color的自定义指令, 指向一个配置对象
			// 当指令首次被绑定到元素上时,会立即触发bind函数, 若DOM更新时,不会触发
			// 形参el为当前被绑定的DOM对象  binding接收data传的值
			bind(el, binding){
				el.style.color = binding.value;
			},	
			update(el, binding){  // DOM更新时触发
				el.style.color = binding.value;
			},
	} */</span>
    <span class="token comment">// 简写 </span>
    <span class="token function">color</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> binding<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="_2-全局自定义指令" tabindex="-1"><a class="header-anchor" href="#_2-全局自定义指令" aria-hidden="true">#</a> (2) 全局自定义指令</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 全局自定义指令  定义在main.js中   通常使用全局自定义指令, 私有的意义不大</span>
Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">&#39;cColor&#39;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
	el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> binding<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三-路由" tabindex="-1"><a class="header-anchor" href="#三-路由" aria-hidden="true">#</a> 三. 路由</h2><h3 id="_1-简介" tabindex="-1"><a class="header-anchor" href="#_1-简介" aria-hidden="true">#</a> 1. 简介</h3><p>router，就是对应关系</p><h4 id="_1-前端路由" tabindex="-1"><a class="header-anchor" href="#_1-前端路由" aria-hidden="true">#</a> (1) 前端路由</h4><ul><li>前端路由：Hash地址与组件之间的对应关系</li><li>Hash地址：锚链接，url地址中 #及#之后的内容就是hash地址</li><li>SPA与前端路由：SPA(单页面)项目中，不同功能之间的切换，依赖于前端路由</li></ul><p><strong>工作方式:</strong></p><ul><li>用户点击页面上的路由链接，导致URL地址栏中的 Hash值发生变化</li><li>前端路由监听了到 Hash地址的变化，把当前 Hash 地址对应的组件渲染到浏览器中</li></ul><p><strong>实现简易前端路由:</strong></p><ul><li>可通过<code>&lt;component&gt;</code>标签, 绑定动态属性渲染组件</li><li>通过<code>&lt;a&gt;</code>添加对象的hash值</li><li>在created()中用 window.onhashchange = () =&gt; { }来监听hash地址的变化，并动态切换要展示的组件</li></ul><h4 id="_2-后端路由" tabindex="-1"><a class="header-anchor" href="#_2-后端路由" aria-hidden="true">#</a> (2) 后端路由</h4><ul><li>请求方式，请求地址与function处理函数之间的对应关系</li><li>在node.js中，express路由，koa路由即为后端路由</li></ul><h3 id="_2-vue-router基本用法" tabindex="-1"><a class="header-anchor" href="#_2-vue-router基本用法" aria-hidden="true">#</a> 2. vue-router基本用法</h3><ul><li>官方给出的路由解决方案，只能结合vue项目进行使用，能够轻松的管理SPA项目中组件的切换</li><li>https://router.vuejs.org</li></ul><p><strong>基本用法</strong></p><ul><li>安装vue-router包：npm i vue-router@3.5.2 -S (vue2安装router版本过高会报错)</li><li>创建路由模块并初始化 src ==&gt; router ==&gt; ndex.js</li><li>导入并挂载路由模块(main.js中)</li><li>组件中声明路由链接<code>&lt;router-link&gt; </code>(替换普通<code>&lt;a&gt;</code>链接)和占位符<code>&lt;router-view&gt;</code></li></ul><h3 id="_3-vue-router常见用法" tabindex="-1"><a class="header-anchor" href="#_3-vue-router常见用法" aria-hidden="true">#</a> 3. vue-router常见用法</h3><h4 id="_1-路由重定向" tabindex="-1"><a class="header-anchor" href="#_1-路由重定向" aria-hidden="true">#</a> (1) 路由重定向</h4><ul><li>访问地址A 时，强制跳转到地址C</li><li>redirect 属性指定一个新的路由地址 e.g：可实现 在/路径 下显示主页</li></ul><h4 id="_2-嵌套路由" tabindex="-1"><a class="header-anchor" href="#_2-嵌套路由" aria-hidden="true">#</a> (2) 嵌套路由</h4><ul><li>通过路由实现组件的嵌套展示</li><li>声明子路由占位符和子路由链接( /父级路径/子级路径 )</li><li>children 属性声明子路由规则</li></ul><h4 id="_3-动态路由匹配" tabindex="-1"><a class="header-anchor" href="#_3-动态路由匹配" aria-hidden="true">#</a> (3) 动态路由匹配</h4><ul><li>把 Hash 地址中可变的部分定义为参数项( :参数)，从而提高路由规则的复用性</li><li>$route.params 参数对象 可访问到动态匹配的参数值</li><li>props 传参，简化的接收路由参数获取形式</li></ul><h4 id="_4-声明式导航-编程式导航" tabindex="-1"><a class="header-anchor" href="#_4-声明式导航-编程式导航" aria-hidden="true">#</a> (4) 声明式导航&amp;编程式导航</h4><ul><li>声明式导航：浏览器中，点击链接实现导航的方式 e.g：普通<code>&lt;a&gt;</code>链接，vue<code>&lt;router-link&gt;</code></li><li>编程式导航：浏览器中，调用 API 方法实现导航的方式 e.g：普通调用location.href</li></ul><h4 id="_5-vue-router编程式导航api" tabindex="-1"><a class="header-anchor" href="#_5-vue-router编程式导航api" aria-hidden="true">#</a> (5) vue-router编程式导航API</h4><p>其中最常用的导航 API 分别是：</p><ul><li>this.$router.push(&#39;hash地址&#39;) 跳转到指定 hash 地址，并增加一条历史记录</li><li>this.$router.replace(&#39;hash地址&#39;) 跳转到指定的 hash 地址，并替换掉当前的历史记录</li><li>this.$router.go(数值n) 实现导航历史前进(正值)，后退(负值)</li><li>$router.back() 在历史记录中，后退到上一个页面</li><li>$router.forward() 在历史记录中，前进到下一个页面</li></ul><h4 id="_6-导航守卫" tabindex="-1"><a class="header-anchor" href="#_6-导航守卫" aria-hidden="true">#</a> (6) 导航守卫</h4><p>控制路由的访问权限</p><p>全局前置守卫 router.beforEach( (to, from, next)=&gt;{ } )</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 仅作为参考，由于vue或vue-router的版本不同可能写法会存在差异，实际使用建议参考官方文档</span>
<span class="token comment">// src-&gt;router-&gt; index.js</span>
<span class="token comment">// 1.下载vue-router@3.5.2包</span>
<span class="token comment">// 2.导入Vue, 路由模块, 以及所需要的组件</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>
<span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">&#39;vue-router&#39;</span>
<span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">&#39;@/components/Router/Home.vue&#39;</span>
<span class="token comment">// 3.使用VueRouter插件</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueRouter<span class="token punctuation">)</span>
<span class="token comment">// 4.创建实例对象</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment">// 7. 定义哈希地址与组件的对应关系  { path: &#39;哈希地址#之后的内容&#39;, component: 组件名  }</span>
    <span class="token literal-property property">routes</span><span class="token operator">:</span><span class="token punctuation">[</span>
        <span class="token comment">// 重定向的路由规则  在/路径下显示主页</span>
        <span class="token punctuation">{</span>  <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">redirect</span><span class="token operator">:</span> <span class="token string">&#39;/home&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment">// 路由规则</span>
        <span class="token punctuation">{</span>  <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/home&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> Home <span class="token punctuation">}</span><span class="token punctuation">,</span> 
        <span class="token comment">// 父级路由规则, Mine页面</span>
        <span class="token punctuation">{</span>  
            <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/mine&#39;</span><span class="token punctuation">,</span>  <span class="token comment">// 父级地址</span>
            <span class="token literal-property property">component</span><span class="token operator">:</span> Mine<span class="token punctuation">,</span>  <span class="token comment">// 父级组件名</span>
            <span class="token comment">// redirect: &#39;/mine/mineabout1&#39;,  //可使用路由重定向, 当访问mine时,直接展示MineAbout1上,  也可使用默认子路由</span>
            <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span>  <span class="token comment">// 通过children属性, 嵌套声明子级路由规则 子路由不使用/</span>
                <span class="token comment">// 默认子路由: children数组中, 某个路由规则的path为空字符串, 打开时,直接展示该子组件上</span>
                <span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;mineabout1&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> MineAbout1 <span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> MineAbout2 <span class="token punctuation">}</span>
            <span class="token punctuation">]</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>	
        <span class="token comment">// 动态参数   在World组件中,根据参数值, 展示对应组件    变化部分写 :参数</span>
        <span class="token comment">// 方式1  this.$route.params.mid 拿到mid</span>
        <span class="token comment">// {  path: &#39;/world/:mid&#39;, component: World },	</span>
        <span class="token comment">// 方式2  设置 props: true  ,在组件中用props接收</span>
        <span class="token punctuation">{</span>  <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/world/:mid&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> World <span class="token punctuation">,</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>	

        <span class="token punctuation">{</span>  <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/main&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> Main <span class="token punctuation">}</span><span class="token punctuation">,</span> 
        <span class="token punctuation">{</span>  <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/login&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> Login <span class="token punctuation">}</span><span class="token punctuation">,</span> 

    <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 8.为router实例对象, 声明全局前置守卫  发生路由跳转,必然触发beforeEach指定的回调函数  to将要访问的路由信息对象, from将要离开的路由信息对象, next()函数 , 表放行</span>
router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from <span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>path <span class="token operator">===</span> <span class="token string">&#39;/main&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 判断用户将要访问的哈希地址是否为/main  </span>
        <span class="token comment">// 访问的是main主页，需要登录才能访问获取localStorage中的token</span>
        <span class="token keyword">const</span> token <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&#39;token&#39;</span><span class="token punctuation">)</span>   <span class="token comment">// 如果在浏览器Application-&gt;localStorage中有token,就可访问到main</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 有token,则放行</span>
            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>  <span class="token comment">// 无token, 则强制跳转到/login</span>
            <span class="token function">next</span><span class="token punctuation">(</span><span class="token string">&#39;/login&#39;</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>   <span class="token comment">// 访问的不是后台主页,直接放行</span>
        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 5.向外共享</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> router

<span class="token comment">// 6. main.js中挂载</span>
<span class="token comment">// 导入路由模块 拿到实例对象</span>
<span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">&#39;@/router/index.js&#39;</span> 
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App2<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// Vue中使用路由, 必须将路由实例对象router进行挂载 </span>
    router<span class="token punctuation">,</span>   <span class="token comment">// router : router  属性名属性值一样,可简写为router</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span>


<span class="token comment">// App.vue组件中项目中安装和配置了vue-router,就可以使用 &lt;router-view&gt;组件来占位  和 &lt;router-link&gt;替代普通a链接 自动加# --&gt;</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link to<span class="token operator">=</span><span class="token string">&quot;/home&quot;</span><span class="token operator">&gt;</span>主页<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link to<span class="token operator">=</span><span class="token string">&quot;/mine&quot;</span><span class="token operator">&gt;</span>我的<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>hr<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 动态参数  哈希地址中<span class="token punctuation">.</span> <span class="token operator">/</span>后的参数项<span class="token punctuation">,</span>叫路径参数<span class="token punctuation">;</span> 在路由参数对象中<span class="token punctuation">,</span>用<span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params访问路径参数<span class="token punctuation">;</span>   <span class="token operator">?</span>后的参数项<span class="token punctuation">,</span>叫查询参数<span class="token punctuation">,</span>用<span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>query访问<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$route中<span class="token punctuation">,</span> path只是路径部分 e<span class="token punctuation">.</span>g<span class="token operator">:</span><span class="token operator">/</span>world<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>  fullPath是完整路径 e<span class="token punctuation">.</span>g<span class="token operator">:</span> <span class="token operator">/</span>world<span class="token operator">/</span><span class="token number">2</span><span class="token operator">?</span>name<span class="token operator">=</span>mm<span class="token operator">&amp;</span>age<span class="token operator">=</span><span class="token number">18</span> <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link to<span class="token operator">=</span><span class="token string">&quot;/world/1&quot;</span><span class="token operator">&gt;</span><span class="token constant">W1</span><span class="token punctuation">.</span>vue<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link to<span class="token operator">=</span><span class="token string">&quot;/world/2?name=mm&amp;age=18&quot;</span><span class="token operator">&gt;</span><span class="token constant">W2</span><span class="token punctuation">.</span>vue<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>hr<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 行内使用编程式导航跳转时<span class="token punctuation">,</span>省略<span class="token keyword">this</span><span class="token punctuation">,</span>否则报错 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">&quot;$router.back()&quot;</span><span class="token operator">&gt;</span>back<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">&quot;$router.forward()&quot;</span><span class="token operator">&gt;</span>forward前进<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,172),f=[b];function _(x,y){return a(),s("div",null,f)}const M=n(g,[["render",_],["__file","Vue2基础知识.html.vue"]]);export{M as default};
